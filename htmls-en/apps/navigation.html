<!DOCTYPE html>
<html lang="en">
        
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />
        <title>Mamo-ruKun</title>
        <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    </head>
    <body style="">
        <div class="orientation-lock-warning-container bubble-container" hidden>
            <h1>Looks like your Screen is locked</h1>
            <h3>free your screen orientation to continue</h3>
   
            <a onclick="window.location.href=`/menu?token=${window.sessionStorage.token}`;">Back to Menu</a>
        </div>
        <div class="permission-container bubble-container" hidden>
            <h1>Allow motion sensor on your device</h1>
            <h3>allow the use of accelerometer on your device to use this feature</h3>
            <button class="allow-button" onclick="requestPermission()">Allow</button>
            <br>
            <a onclick="window.location.href=`/menu?token=${window.sessionStorage.token}`;">Back to Menu</a>
        </div>
        <div class="orientation-warning-container bubble-container" hidden>
            <h1>Looks like your screen orientation is not right</h1>
            <h3>please rotate your screen to portrait orientation</h3>

            <a onclick="window.location.href=`/menu?token=${window.sessionStorage.token}`;">Back to Menu</a>
        </div>
        <div class="survey-container bubble-container" hidden>
            <h1>Select your vehicle</h1>
            <h3>please select what you are riding</h3>
            
            <button class="bike" onclick="selectVehicle('bike')">Bike</button><br>
            <button class="car" onclick="selectVehicle('car')">Car</button><br>
            
            <button class="tomaru-link-button" onclick="window.location.href=`/apps/navigation-tomaruKun?token=${window.sessionStorage.token}&lang=${window.sessionStorage.language}`">
                <span class="material-symbols-outlined">smartphone</span>
                <span class="material-symbols-outlined">link</span>
                <span class="material-symbols-outlined">pedal_bike</span>
                <br>
                Link with Tomaru Kun
            </button>
            <br>
            <a onclick="window.location.href=`/menu?token=${window.sessionStorage.token}`;">Back to Menu</a>
        </div>
        <div class="calibration-container bubble-container" hidden>
            <h1>Sensor Calibration</h1>
            <h3>You're almost there!</h3>
            <h2>When you're device is stable and ready, press the button below to start the calibration</h2>
            
            <button class="calibrate-button" onclick="startCalibration()">start</button><br>
            
            <br>
            <a onclick="window.location.href=`/menu?token=${window.sessionStorage.token}`;">Back to Menu</a>
        </div>
        <div class="main-container" hidden>
            <div class="signal-meter" style="position: absolute; right: 20px; top: 10px;">
                <div class="signal-meter-bars" style="display: flex; flex-direction: row;">
                    <div class="signal-meter-0 signal-bar" style="height: 20px; margin-top: 30px;"></div>
                    <div class="signal-meter-1 signal-bar" style="height: 30px; margin-top: 20px;"></div>
                    <div class="signal-meter-2 signal-bar" style="height: 40px; margin-top: 10px;"></div>
                    <div class="signal-meter-3 signal-bar" style="height: 50px; margin-top: 0px;"></div>
                </div>
                <h2 style="margin-top: 5px;">GPS</h2>
            </div>
            <h1 style="color: #bebebe;"><span class="speedometer" style="color: white; font-size: 10rem;">---</span> km/h</h1>
            <h1 style="color: #bebebe;"><span class="compass" style="color: white; font-size: 5rem;">-- ---</span></h1>
            <h1 style="color: #bebebe;"><span class="total-distance" style="color: white; font-size: 5rem;">---</span> km</h1>
            <button onclick="summary();" class="done-button" style="font-size: 2rem; color: black;">Done</button>
            
            <!--Delete on Deployment-->
            
            <button onclick="_debug_copy_vehilceDataRetrievalDurations();">Copy vehilceDataRetrievalDurations</button>
            <h4 class="gravityVector">GravityVector: ---</h4>
            <h4 class="accelerationOrientation">Orientation: ---</h4>
            <h4 class="accelerationType">Type: ---</h4>
            <h4 class="n-vehicles">#Vehicles</h4>
            <h4 class="log"></h4>
            !
            <!---->
        </div>
        <div class="alert-container" hidden>
            <div class="alert-window" >
                <div name="alert-distance" style="background-color: red;">
                    <h1 style="font-size: 5rem; color: rgb(106, 255, 0);"><span class="alert-distance">100</span>m ahead</h1>
                </div>
                
                <div name="alert-content" class="alert-blink">
                    <img src="/imgs/apps/navigation/warning.png" alt="warning sign" width="75%" style="margin-top: 20px;">
                    <h1 class="alert-message" style="color: black; font-size: 4rem; margin-left: 15px; margin-right: 15px;">alert message</h1>
                </div>
            </div>
        </div>
        <svg xmlns:xlink="http://www.w3.org/1999/xlink" style="position: absolute; bottom:-10px; left: 0px; z-index: -1000;" height="30%" viewBox="0 0 1440 190" version="1.1" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="sw-gradient-0" x1="0" x2="0" y1="1" y2="0"><stop stop-color="rgba(62, 99.619, 243, 1)" offset="0%"/><stop stop-color="rgba(11, 185.497, 255, 1)" offset="100%"/></linearGradient></defs><path style="transform:translate(0, 0px); opacity:1" fill="url(#sw-gradient-0)" d="M0,76L10.4,76C20.9,76,42,76,63,79.2C83.5,82,104,89,125,95C146.1,101,167,108,188,101.3C208.7,95,230,76,250,63.3C271.3,51,292,44,313,38C333.9,32,355,25,376,41.2C396.5,57,417,95,438,107.7C459.1,120,480,108,501,114C521.7,120,543,146,563,152C584.3,158,605,146,626,126.7C647,108,668,82,689,85.5C709.6,89,730,120,751,117.2C772.2,114,793,76,814,57C834.8,38,856,38,877,60.2C897.4,82,918,127,939,123.5C960,120,981,70,1002,44.3C1022.6,19,1043,19,1064,34.8C1085.2,51,1106,82,1127,101.3C1147.8,120,1169,127,1190,114C1210.4,101,1231,70,1252,69.7C1273,70,1294,101,1315,95C1335.7,89,1357,44,1377,28.5C1398.3,13,1419,25,1440,34.8C1460.9,44,1482,51,1492,53.8L1502.6,57L1502.6,190L1492.2,190C1481.7,190,1461,190,1440,190C1419.1,190,1398,190,1377,190C1356.5,190,1336,190,1315,190C1293.9,190,1273,190,1252,190C1231.3,190,1210,190,1190,190C1168.7,190,1148,190,1127,190C1106.1,190,1085,190,1064,190C1043.5,190,1023,190,1002,190C980.9,190,960,190,939,190C918.3,190,897,190,877,190C855.7,190,835,190,814,190C793,190,772,190,751,190C730.4,190,710,190,689,190C667.8,190,647,190,626,190C605.2,190,584,190,563,190C542.6,190,522,190,501,190C480,190,459,190,438,190C417.4,190,397,190,376,190C354.8,190,334,190,313,190C292.2,190,271,190,250,190C229.6,190,209,190,188,190C167,190,146,190,125,190C104.3,190,83,190,63,190C41.7,190,21,190,10,190L0,190Z"/><defs><linearGradient id="sw-gradient-1" x1="0" x2="0" y1="1" y2="0"><stop stop-color="rgba(62, 191.251, 250, 1)" offset="0%"/><stop stop-color="rgba(11, 226.357, 255, 1)" offset="100%"/></linearGradient></defs><path style="transform:translate(0, 50px); opacity:0.9" fill="url(#sw-gradient-1)" d="M0,38L10.4,44.3C20.9,51,42,63,63,57C83.5,51,104,25,125,41.2C146.1,57,167,114,188,114C208.7,114,230,57,250,28.5C271.3,0,292,0,313,28.5C333.9,57,355,114,376,126.7C396.5,139,417,108,438,82.3C459.1,57,480,38,501,31.7C521.7,25,543,32,563,47.5C584.3,63,605,89,626,101.3C647,114,668,114,689,117.2C709.6,120,730,127,751,120.3C772.2,114,793,95,814,79.2C834.8,63,856,51,877,50.7C897.4,51,918,63,939,72.8C960,82,981,89,1002,85.5C1022.6,82,1043,70,1064,76C1085.2,82,1106,108,1127,101.3C1147.8,95,1169,57,1190,44.3C1210.4,32,1231,44,1252,69.7C1273,95,1294,133,1315,126.7C1335.7,120,1357,70,1377,41.2C1398.3,13,1419,6,1440,31.7C1460.9,57,1482,114,1492,142.5L1502.6,171L1502.6,190L1492.2,190C1481.7,190,1461,190,1440,190C1419.1,190,1398,190,1377,190C1356.5,190,1336,190,1315,190C1293.9,190,1273,190,1252,190C1231.3,190,1210,190,1190,190C1168.7,190,1148,190,1127,190C1106.1,190,1085,190,1064,190C1043.5,190,1023,190,1002,190C980.9,190,960,190,939,190C918.3,190,897,190,877,190C855.7,190,835,190,814,190C793,190,772,190,751,190C730.4,190,710,190,689,190C667.8,190,647,190,626,190C605.2,190,584,190,563,190C542.6,190,522,190,501,190C480,190,459,190,438,190C417.4,190,397,190,376,190C354.8,190,334,190,313,190C292.2,190,271,190,250,190C229.6,190,209,190,188,190C167,190,146,190,125,190C104.3,190,83,190,63,190C41.7,190,21,190,10,190L0,190Z"/></svg>
        <script>
            const speedometer = document.querySelector(".speedometer");
            const compass = document.querySelector(".compass");
            const totalDistanceMeter = document.querySelector(".total-distance");
            
            let boundWidth;
            let boundHeight;

            let selectedVehicle;

            let accelerationThreshold = 0;
            let gravityVector;

            let currentAcceleration = {};
            let currentAccelerationWtihGravity = {};
            let currentSpeed = 0;
            let currentDirection = 0;
            let currentPosition;

            let lastPosition;
            let lastPositionUpdate = Date.now();
            let positionUpdate = false;

            let surroundingAccidents;
            let locationOfLastSurroundingUpdate;

            let surroundingVehicles;

            let totalDistanceTraveled = 0;

            let baseOrientation;

            let timeLastSentAccident;

            let accelerationDurationType= "none";
            let accelerationDurationStart = 0;
            let accelerationDurationThreshold = 0;

            const distanceSounds = {
                10: new Audio("/sounds/en/10m.mp3"),
                20: new Audio("/sounds/en/20m.mp3"),
                30: new Audio("/sounds/en/30m.mp3"),
                40: new Audio("/sounds/en/40m.mp3"),
                50: new Audio("/sounds/en/50m.mp3"),
                60: new Audio("/sounds/en/60m.mp3"),
                70: new Audio("/sounds/en/70m.mp3"),
                80: new Audio("/sounds/en/80m.mp3"),
                90: new Audio("/sounds/en/90m.mp3"),
                100: new Audio("/sounds/en/100m.mp3"),
            };
            const suddenBrakeWarningSound = new Audio("/sounds/en/sudden_brake.mp3");
            const rearImpactWarningSound = new Audio("/sounds/en/rear_impact.mp3");

            const _debug_vehilceDataRetrievalDurations = [];
            const _debug_vehicleDataUploadInternalDelays = [];
            const _debug_vehicleDataRetrievalInternalDelays = [];

            // ---------------------------------- debug ----------------------------------
            function _debug_copy_vehilceDataRetrievalDurations(){
                navigator.clipboard.writeText(JSON.stringify({
                    vehicleDataRetrievalDurations: _debug_vehilceDataRetrievalDurations,
                    vehicleDataUploadInternalDelays: _debug_vehicleDataUploadInternalDelays,
                    vehicleDataRetrievalInternalDelays: _debug_vehicleDataRetrievalInternalDelays
                }));
            }

            // ---------------------------------- main process ----------------------------------
            function updateMeasurements(){
                conversionTable = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
                compassSection = Math.floor((currentDirection + 22.5)/45) % 8;

                speedometer.innerHTML = Math.round(currentSpeed);
                compass.innerHTML = `${conversionTable[compassSection]} ${Math.round(currentDirection)}°`;
                totalDistanceMeter.innerHTML = firstNDigits(totalDistanceTraveled/1000, 3);

                const accuracy = currentPosition.accuracy;
                const zero = document.querySelector(".signal-meter-0");
                const one = document.querySelector(".signal-meter-1");
                const two = document.querySelector(".signal-meter-2");
                const three = document.querySelector(".signal-meter-3");
                if(accuracy < 10){
                    //4
                    zero.style.opacity = "100%";
                    one.style.opacity = "100%";
                    two.style.opacity = "100%";
                    three.style.opacity = "100%";
                }else if(accuracy < 15){
                    //3
                    zero.style.opacity = "100%";
                    one.style.opacity = "100%";
                    two.style.opacity = "100%";
                    three.style.opacity = "30%";
                }else if(accuracy < 20){
                    //2
                    zero.style.opacity = "100%";
                    one.style.opacity = "100%";
                    two.style.opacity = "30%";
                    three.style.opacity = "30%";
                }else if(accuracy < 25){
                    //1
                    zero.style.opacity = "100%";
                    one.style.opacity = "30%";
                    two.style.opacity = "30%";
                    three.style.opacity = "30%";
                }else{
                    //0
                    zero.style.opacity = "30%";
                    one.style.opacity = "30%";
                    two.style.opacity = "30%";
                    three.style.opacity = "30%";
                }
            }

            //detect accidents
            function detectAccident(){
                if(currentAcceleration == null){
                    return;
                }

                const calibrated = remapVector(currentAcceleration, baseOrientation);
                const accelerationStrength = Math.sqrt(calibrated.y ** 2 + calibrated.z ** 2);

                let accelerationOrientation;
                if(calibrated.y < 0){
                    accelerationOrientation = (Math.PI + Math.tan(calibrated.z / calibrated.y)) % (Math.PI*2);
                }else{
                    accelerationOrientation = Math.tan(calibrated.z / calibrated.y);
                }
                accelerationOrientation = (rad2deg(Math.PI*2+accelerationOrientation)+360) % 360;

                // guard clauses to not let the bump get detected
                if(accelerationStrength < accelerationThreshold){
                    accelerationDurationStart = Date.now();
                    return;
                }
                if(Date.now() - timeLastSentAccident < 3000){
                    return;
                }
                document.querySelector(".accelerationOrientation").innerHTML = `Orientation: ${firstNDigits(accelerationOrientation, 3)}`;
                document.querySelector(".accelerationType").innerHTML = `Type: ${accelerationDurationType}`;
                if(currentSpeed < 6){
                    return;
                }

                //error of 30 degrees
                const error = 30;
                if((180+error <= accelerationOrientation && accelerationOrientation <= 360-error) || (error <= accelerationOrientation && accelerationOrientation <= 180-error)){
                    //random shake detected
                    //document.querySelector(".log").innerHTML += "random shake<br>";
                    accelerationDurationStart = Date.now();
                    accelerationDurationType = "none";
                }else{
                    //document.querySelector(".log").innerHTML += `${accelerationOrientation}<br>`;
                    if(accelerationOrientation == null){
                        return;
                    }
                    if(180-error < accelerationOrientation && accelerationOrientation < 180+error){
                        // rear-end collision
                        document.querySelector(".accelerationType").innerHTML = "Type: rear impact";
                        //document.querySelector(".log").innerHTML += `R ${Date.now() - accelerationDurationStart}<br>`;
                        if(accelerationDurationType != "rear impact"){
                            accelerationDurationStart = Date.now();
                        }
                        accelerationDurationType = "rear impact";
                    }
                    if(360-error < accelerationOrientation || accelerationOrientation < error){
                        // sudden brake
                        document.querySelector(".accelerationType").innerHTML = "Type: brake";
                        //document.querySelector(".log").innerHTML += `B ${Date.now() - accelerationDurationStart}<br>`;
                        if(accelerationDurationType != "brake"){
                            accelerationDurationStart = Date.now();
                        }
                        accelerationDurationType = "brake";
                    }
                    if(Date.now() - accelerationDurationStart > accelerationDurationThreshold && accelerationDurationType != "none"){
                        console.log(`${accelerationDurationType} detected`);
                        document.querySelector(".log").innerHTML += `${accelerationDurationType} detected<br>`;
                        sendAccident(accelerationDurationType);
                        timeLastSentAccident = Date.now();
                    }
                }
            }
            //check for approaching vehicles
            function checkForApproachingVehicles(){
                for(i in surroundingVehicles){
                    vehicle = surroundingVehicles[i];

                    if(Math.abs(currentDirection - vehicle.direction) % 180 > 50){
                        continue;
                    }

                    const { doesIntersect, intersection } = checkIntersection(
                        [currentPosition.longitude, currentPosition.latitude],
                        currentDirection,
                        currentSpeed * 2.222,
                        [vehicle.lon, vehicle.lat],
                        vehicle.direction,
                        vehicle.speed * 2.222,
                    );

                    if(!doesIntersect){
                        continue
                    }
                    
                    //vehicle approaching
                    approachingDirection = Math.abs(vehicle.direction - currentDirection);
                    distanceToIntersection = getDistanceOnEarth(
                        currentPosition.latitude, currentPosition.longitude,
                        intersection[1], intersection[0]
                    )
                    if(Math.abs(approachingDirection - 270) < 45){
                        //from right
                        console.log("vehicle approaching from right")
                    }
                    if(Math.abs(approachingDirection - 90) < 45){
                        //from left
                        console.log("vehicle approaching from left")
                    }
                }
            }
            async function sendVehicleData(){
                fetch("/apps/navigation/sendVehicleData",{
                    method: "POST",
                    body:JSON.stringify({
                        token: window.sessionStorage.token,
                        location: {lat: currentPosition.latitude, lon: currentPosition.longitude},
                        direction: currentDirection,
                        speed: currentSpeed,
                        type: selectedVehicle,
                        timestamp: lastPositionUpdate
                    }),
                    headers: {
                        "Content-Type": "application/json"
                    }
                })
                .then(res => res.text())
                .then(res => {
                    _debug_vehicleDataUploadInternalDelays.push(res);
                })
            }

            //check for accidents in sight
            function checkForAccidents(){
                if(currentPosition == null || currentDirection == null){
                    return;
                }
                let locations = findDangerLocationsWithinRange(
                    currentPosition, 
                    currentDirection, 
                    getAngleFromDistanceOnEarth(currentPosition.latitude, boundWidth/1000), 
                    getAngleFromDistanceOnEarth(0, boundHeight/1000),
                    surroundingAccidents,
                );
                console.log(locations.length);
                const convertToMessage = {
                    "brake": "There was an emergency brake",
                    "rear impact": "There was a rear-end collision"
                }
                for(index in locations){
                    if ('alerted' in locations[index]){
                        continue;
                    }
                    var location = locations[index];
                    distanceToAccident = getDistanceOnEarth(currentPosition.latitude, currentPosition.longitude, location.location.lat, location.location.lon);
                    alertAccident(firstNDigits(distanceToAccident*1000, 2), convertToMessage[location.type], 7000, location.type);
                    //surroundingAccidents[index]["alerted"] = true;
                    var coordinate = location.location;
                    for(i in surroundingAccidents){
                        var loc = surroundingAccidents[i].location;
                        if(getDistanceOnEarth(coordinate.lat, coordinate.lon, loc.lat, loc.lon)*1000 < 10){
                            surroundingAccidents[i]["alerted"] = true;
                        }
                    }
                }
            }
            
            //function to alert the accident
            function alertAccident(distance, message, duration, type){
                document.querySelector(".alert-distance").innerHTML = distance;
                document.querySelector(".alert-message").innerHTML = message;
                document.querySelector(".alert-container").hidden = false;
                const startBlink = Date.now();
                const loop = setInterval(() => {
                    document.querySelector(".alert-blink").hidden = !document.querySelector(".alert-blink").hidden;
                    if(Date.now() - startBlink >= duration){
                        document.querySelector(".alert-container").hidden = true;
                        clearInterval(loop);
                    }
                }, 800);
                const roundedDistance = Math.round(distance/10) * 10;
                const distanceSoundToPlay = distanceSounds[roundedDistance];
                let warningSoundToPlay;
                let waitTime = 0;
                if(type == "brake"){
                    warningSoundToPlay = suddenBrakeWarningSound;
                    waitTime = 1700;
                }else if(type == "rear impact"){
                    warningSoundToPlay = rearImpactWarningSound;
                    waitTime = 1700;
                }
                navigator.vibrate(1000);
                warningSoundToPlay.play();
                setTimeout(() => {
                    distanceSoundToPlay.play();
                }, waitTime);
            }

            //update surrounding accidents
            async function updateDangerLocations(){
                if(locationOfLastSurroundingUpdate == null){
                    const pos = (await getPos()).coords;
                    surroundingAccidents = await (await fetch(`/apps/navigation/getData?lat=${pos.latitude}&lon=${pos.longitude}`)).json();
                    locationOfLastSurroundingUpdate = pos;
                    return;
                }
                if(getDistanceOnEarth(locationOfLastSurroundingUpdate.latitude, locationOfLastSurroundingUpdate.longitude, currentPosition.latitude, currentPosition.longitude) >= 5000){
                    surroundingAccidents = await (await fetch(`/apps/navigation/getData?lat=${currentPosition.latitude}&lon=${currentPosition.longitude}`)).json();
                    locationOfLastSurroundingUpdate = currentPosition;
                    return;
                }
            }
            async function updateVehicleDatas(){
                if(currentPosition == null){
                    currentPosition = (await getPos()).coords;
                }
                const start = Date.now();
                surroundingVehicles = await (await fetch(`/apps/navigation/getVehicleData?lat=${currentPosition.latitude}&lon=${currentPosition.longitude}`)).json();
                _debug_vehilceDataRetrievalDurations.push(Date.now() - start);
                _debug_vehicleDataRetrievalInternalDelays.push({n_vehicles: Object.keys(surroundingVehicles).length - 1, internalDelay: surroundingVehicles.internalDelay});
                document.querySelector(".n-vehicles").innerHTML = `#Vehicles: ${Object.keys(surroundingVehicles).length}`;
            }
            async function startMain(){
                const settings = await (await fetch(`/getSettings?username=${window.sessionStorage.username}`)).json();
                boundWidth = settings.detectionBoxWidth;
                boundHeight = settings.detectionBoxHeight;
                setInterval(updateMeasurements, 500);
                setInterval(detectAccident);
                setInterval(checkForAccidents, 1000);
                updateDangerLocations();
                setInterval(updateDangerLocations, 60000);
                setInterval(updateVehicleDatas, 2500);
            }
            

            // ----------------------------------- summary and leave -----------------------------------
            function summary(){
                if(!confirm(`Total distance traveled: ${parseFloat(parseFloat((totalDistanceTraveled / 1000).toFixed(2)).toPrecision(3))} km`)){
                    return;
                }
                fetch("/apps/navigation/sendSummary", {
                    method: "POST",
                    body: JSON.stringify({
                        username: window.sessionStorage.username,
                        distanceTraveled: totalDistanceTraveled
                    }),
                    headers:{
                        "Content-Type": "application/json"
                    }
                });
                window.location.href = `/menu?token=${window.sessionStorage.token}`;
            }

            // ---------------------------------- system flow controls ----------------------------------
            //check phone orientation
            checkScreenOrientation();
            function checkScreenOrientation(){
                if(window.screen.width > window.screen.height){
                    document.querySelector(".orientation-warning-container").hidden = false;
                    const waitForOrientationCorrection = setInterval(() => {
                        if(window.screen.width < window.screen.height){
                            document.querySelector(".orientation-warning-container").hidden = true;
                            document.querySelector(".survey-container").hidden = false;
                            clearInterval(waitForOrientationCorrection);
                        }
                    });
                }else{
                    document.querySelector(".survey-container").hidden = false;
                }
            }

            function selectVehicle(vehicle){
                askSensorPermission();
                selectedVehicle = vehicle;
                if (vehicle == "bike"){
                    accelerationThreshold = 25;
                    accelerationDurationThreshold = 100;
                }else if(vehicle == "car"){
                    accelerationThreshold = 10;
                    accelerationDurationThreshold = 150;
                }
                document.querySelector(".survey-container").hidden = true;
                document.querySelector(".calibration-container").hidden = false;
            }
            function startCalibration(){
                const button = document.querySelector(".calibrate-button");
                button.disabled = true;
                const startTime = Date.now()
                let xTotal = 0;
                let yTotal = 0;
                let zTotal = 0;
                let samples = 0;
                const loop = setInterval(() => {
                    if(Date.now() - startTime >= 3000){
                        document.querySelector(".calibration-container").hidden = true;
                        document.querySelector(".main-container").hidden = false;
                        gravityVector = {x: xTotal / samples, y: yTotal / samples, z: zTotal / samples};
                        baseOrientation = Math.PI/2 - Math.atan(zTotal / yTotal);
                        if(gravityVector.y > 0){
                            baseOrientation = (baseOrientation + Math.PI) % (2*Math.PI);
                        }
                        main();
                        clearInterval(loop);
                    }
                    xTotal += currentAccelerationWtihGravity.x;
                    yTotal += currentAccelerationWtihGravity.y;
                    zTotal += currentAccelerationWtihGravity.z;
                    samples += 1;
                    button.innerHTML = Math.round((startTime + 3000 - Date.now())/100)/10;
                }, 75);
            }
            function main(){
                startMain();
                /*document.querySelector(".gravityVector").innerHTML = `GravityVector:<br>x: ${gravityVector.x}<br>y: ${gravityVector.y}<br>z: ${gravityVector.z}<br>`;
                console.log(`x: ${gravityVector.x}\ny: ${gravityVector.y}\nz: ${gravityVector.z}\n`);
                console.log(`baseOrientation: ${rad2deg(baseOrientation)} deg`);*/
            }

            // ---------------------------------- update sensors -----------------------------------
            async function askSensorPermission () {
                if ( typeof( DeviceMotionEvent ) !== "undefined" && typeof( DeviceMotionEvent.requestPermission ) === "function" ) {
                    console.log("ios device detected");
                    // (optional) Do something before API request prompt.
                    const response = await DeviceMotionEvent.requestPermission();
                    console.log(response);
                    if(response == "granted"){
                        window.addEventListener("devicemotion",(event) => {
                            currentAcceleration = {x: -event.acceleration.x, y: -event.acceleration.y, z: -event.acceleration.z};
                            currentAccelerationWtihGravity = {x: -event.accelerationIncludingGravity.x, y: -event.accelerationIncludingGravity.y, z: -event.accelerationIncludingGravity.z};
                        });
                    }

                    /*
                    DeviceMotionEvent.requestPermission()
                    .then( response => {
                        console.log(response);
                        // (optional) Do something after API prompt dismissed.
                        if ( response == "granted" ) {
                            window.addEventListener("devicemotion",(event) => {
                                currentAcceleration = {x: -event.acceleration.x, y: -event.acceleration.y, z: -event.acceleration.z};
                                currentAccelerationWtihGravity = {x: -event.accelerationIncludingGravity.x, y: -event.accelerationIncludingGravity.y, z: -event.accelerationIncludingGravity.z};
                            });
                        }
                    })
                    .catch(err => console.error(err));*/
                } else {
                    console.log("non ios device detected");
                    window.addEventListener("devicemotion",(event) => {
                        currentAcceleration = {x: -event.acceleration.x, y: -event.acceleration.y, z: -event.acceleration.z};
                        currentAccelerationWtihGravity = {x: -event.accelerationIncludingGravity.x, y: -event.accelerationIncludingGravity.y, z: -event.accelerationIncludingGravity.z};
                        //document.querySelector(".accelerationOrientation").innerHTML = `x: ${event.accelerationIncludingGravity.x}<br>y: ${event.accelerationIncludingGravity.y}<br>z: ${event.accelerationIncludingGravity.z}`;
                    });
                }
                startSensors();
            }
            function startSensors(){
                navigator.geolocation.watchPosition(
                    pos => {
                        deltaTime = (pos.timestamp - lastPositionUpdate)/1000
                        if(deltaTime < 1){
                            return;
                        }

                        currentPosition = pos.coords;
                        
                        if (lastPosition == null){
                            lastPosition = currentPosition
                            return;
                        }
                        distanceFromPreviousMeasurement  = getDistanceOnEarth(
                            lastPosition.latitude,
                            lastPosition.longitude,
                            currentPosition.latitude,
                            currentPosition.longitude,
                        ) * 1000;

                        if(currentSpeed == 0){
                            if(distanceFromPreviousMeasurement > 4 * deltaTime){
                                currentSpeed = (distanceFromPreviousMeasurement / deltaTime) * 3.6;
                            }
                        }else{
                            currentSpeed = (distanceFromPreviousMeasurement / deltaTime) * 3.6;
                        }
    
                        if(distanceFromPreviousMeasurement > deltaTime * 3){
                            deltaLat = currentPosition.latitude - lastPosition.latitude;
                            deltaLon = currentPosition.longitude - lastPosition.longitude;
                            rawAngle = Math.atan2(deltaLat, deltaLon) * 180 / Math.PI;
                            currentDirection = 360 - (rawAngle-90 + 360)%360;
                        }
                        if(distanceFromPreviousMeasurement > deltaTime * 1){
                            totalDistanceTraveled += distanceFromPreviousMeasurement;
                        }

                        
                        positionUpdate = true;
                        lastPosition = currentPosition;
                        lastPositionUpdate = pos.timestamp;
                        //console.log(accuracy);
                        //console.log(currentDirection);
                        //console.log(`dist: ${distanceFromPreviousMeasurement}`);
                        //console.log(`speed: ${currentSpeed}`)
                        sendVehicleData();
                    },
                    err => {
                        console.log(err)
                    },
                    {
                        enableHighAccuracy: true
                    }
                )
            }

            // ----------------------------------- general functions -------------------------------------
            function remapVector(vec, radians){
                x = vec.x;
                y = vec.y;
                z = vec.z;
                newY = y * Math.cos(radians) - z * Math.sin(radians);
                newZ = z * Math.cos(radians) + y * Math.sin(radians)
                return {x: x, y: newY, z: newZ};
            }
            function sendAccident(type){
                fetch("/apps/navigation/sendData", {
                    method: "POST",
                    body: JSON.stringify({
                        type: type,
                        location: {
                            lat: lastPosition.latitude,
                            lon: lastPosition.longitude,
                        },
                        username: window.sessionStorage.username,
                        img: ""
                    }),
                    headers:{
                        "Content-Type": "application/json"
                    }
                });
            }
            function firstNDigits(val, digits) {
                const valString = val.toString();
                let result = "";
                let decimalPassed = false;
                for (let i = 0; i < valString.length; i++) {
                    if (valString[i] === ".") {
                        result += ".";
                        decimalPassed = true;
                    } else if (i >= digits + decimalPassed) {
                        if (decimalPassed) {
                            return result;
                        }
                        result += "0";
                    } else {
                        result += valString[i];
                    }
                }
                return result;
            }
            function digitAt(val, index) {
                return Math.floor(
                    (
                    val / Math.pow(10, Math.floor(Math.log(Math.abs(val)) / Math.LN10)-index)
                    )
                    % 10
                );
            };
            function getDistanceOnEarth(lat1,lon1,lat2,lon2) {
                var R = 6371; // Radius of the earth in km
                var dLat = deg2rad(lat2-lat1);  // deg2rad below
                var dLon = deg2rad(lon2-lon1); 
                var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2); 
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
                var d = R * c; // Distance in km
                return d;
            }
            function getAngleFromDistanceOnEarth(latitude, distance){
                //return distance / (Math.cos(deg2rad(latitude)) * 12742 * Math.PI / 360);
                return (distance * 180) / (6371 * Math.cos(deg2rad(latitude)) * Math.PI);
            }
            // code for detecting surrounding dangers
            const side = (origin, user_theta, w) => {
                const x1 = origin[0] + w*Math.round(Math.cos(deg2rad(user_theta)));
                const y1 = origin[1] + w*Math.round(Math.sin(deg2rad(user_theta)));
                const x2 = origin[0] - w*Math.round(Math.cos(deg2rad(user_theta)));
                const y2 = origin[1] - w*Math.round(Math.sin(deg2rad(user_theta)));
                const origin_a1 = [x1,y1];
                const origin_a2 = [x2,y2];
                const origin_a = [origin_a1,origin_a2];
                return origin_a;
            }

            const shift = (origin, user_theta, h) => {
                const x1 = origin[0] + h*Math.round(Math.cos(deg2rad(90-user_theta)));
                const y1 = origin[1] + h*Math.round(Math.sin(deg2rad(90-user_theta)));
                const origin_a = [x1,y1];
                return origin_a;
            }

            const extractLocations = (locations, points) => {
                //return locations.filter(location => countIntersections([location.location.lat, location.location.lon], points))
                dataToKeep = {}
                for(let i = 0; i < locations.length; i++ ){
                    lat = locations[i].location.lat;
                    lon = locations[i].location.lon;
                    if(countIntersections([lon, lat], points)){
                        dataToKeep[i] = locations[i];
                    }
                }
                console.log(Object.keys(dataToKeep).length);
                return dataToKeep;
            }

            const countIntersections = (origin, points) => {
                let count = 0;
                for (let i = 0; i < 4; i++) {
                    const pt1 = points[i];
                    const pt2 = points[i - 1 < 0 ? points.length - 1 : i - 1];
                    if (isIntersecting(origin, pt1, pt2)) {
                        count += 1;
                    }
                }
                return count % 2 === 1;
            }

            const isIntersecting = (origin, pt1, pt2) => {
                const [x1, y1] = pt1;
                const [x2, y2] = pt2;
                const [x, y] = origin;
                if (x1 - x2 === 0) {
                    return (y1 < y && y < y2  ||  y2 < y && y < y1) && x < x1;
                } else if (y1 - y2 === 0) {
                    return false;
                } else {
                    const A = (y1 - y2) / (x1 - x2);
                    const B = y1 - A * x1;
                    const X = (y - B) / A;
                    const isYInRange = y1 < y && y < y2  ||  y2 < y && y < y1;
                    const isXInRange = (x1 < X && X < x2  ||  x2 < X && X < x1)  &&  x < X;
                    return isXInRange && isYInRange;
                }
            }

            /*
            points1 = side(user_loc,user_theta,w)
            points2 = shift(user_loc,user_theta,h)
            points3 = side(points2,user_theta,w)
            points =(points1[0],points1[1],points3[1],points3[0])
            */

            const calcBoundingBox = (userPosition, angle, w, h) => {
                const points1 = side(userPosition, angle, w);
                //console.log(points1);
                const points2 = shift(userPosition, angle, h);
                //console.log(points2);
                const points3 = side(points2, angle, w);
                //console.log(points3);
                return [points1[0], points1[1], points3[1], points3[0]];
            }

            const findDangerLocationsWithinRange = (userPos, angle, w, h, dangerLocations) => {
                userPos = [userPos.longitude, userPos.latitude];
                const boundingBox = calcBoundingBox(userPos, angle, w, h);
                return extractLocations(dangerLocations, boundingBox);
            }

            function checkIntersection(p, a, length_p, q, b, length_q) {
                // Generate equations of the two lines: y = m1*x + c1 and y = m2*x + c2
                var m1 = Math.tan(deg2rad(a));  // Slope of the line extending from point P in direction a
                var c1 = p[1] - m1*p[0];  // y-intercept = y - m*x
                var m2 = Math.tan(deg2rad(b));  // Slope of the line extending from point Q in direction b
                var c2 = q[1] - m2*q[0];  // y-intercept = y - m*x

                // If the lines aren't parallel, they intersect
                if (m1 !== m2) {
                    var x = (c2 - c1) / (m1 - m2);
                    var y = m1 * x + c1;

                    // Check if intersection point is in the correct direction from each line's start point
                    var direction_p = Math.sqrt(Math.pow((x - p[0]), 2) + Math.pow((y - p[1]), 2));
                    var direction_q = Math.sqrt(Math.pow((x - q[0]), 2) + Math.pow((y - q[1]), 2));

                    // Check if intersection point is within the specified lengths from each line's start point
                    if (direction_p <= length_p && direction_q <= length_q) {
                        return { doesIntersect: true, pointOfIntersection: [x, y] };
                    }
                }
                
                return { doesIntersect: false, pointOfIntersection: null };
            }

            function deg2rad(deg) {
                return deg * (Math.PI/180);
            }
            function rad2deg(rad) {
                return rad * (180/Math.PI);
            }
            function getPos(){
                return new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject, {enableHighAccuracy:true}));
            }
            function back(){
                alert(`You've traveled for ${(totalDistanceTraveled/1000).toPrecision(3)}km`);
                window.location.href = `/menu?token=${window.sessionStorage.token}`;
            }
            function sleep(miliseconds) {
                var currentTime = new Date().getTime();
                while (currentTime + miliseconds >= new Date().getTime()) { }
            }
            setInterval(()=>{
                fetch("/updateToken",{
                    method: "POST",
                    body: JSON.stringify({
                        token: window.sessionStorage.token
                    }),
                    headers:{
                        "Content-Type": "application/json"
                    }
                });
            }, 20000);
            fetch("/updateToken",{
                method: "POST",
                body: JSON.stringify({
                    token: window.sessionStorage.token
                }),
                headers:{
                    "Content-Type": "application/json"
                }
            });
        </script>

        <style>
            /*rgba(62, 191.251, 250, 1)" offset="0%"/><stop stop-color="rgba(11, 226.357, 255, 1)*/
            body{
                font-family: Arial;
                height: 100vh;
                background: rgb(0,156,161);
                background-color: #5523a7;
                width: 100vw;
                overflow: hidden;
            }
            a{
                color: white;
                text-decoration: none;
            }
            a:hover{
                color: rgb(157, 206, 255);
                text-decoration: underline;
            }
            h1{
                margin: 0px;
                color: whitesmoke;
            }
            h3{
                margin: 0;
                margin-bottom: 10px;
                color: gray;
            }
            h2{
                color: rgb(215, 215, 215);
            }
            .bike{
                background-color: rgba(62, 191.251, 250, 1);
                height:100px;
                color:black;
                font-size: 60px;
            }
            .bike:hover{
                background-color: rgba(11, 226.357, 255, 1);
                border: thin solid rgb(4, 0, 255);
            }
            .calibrate-button{
                background-color: rgba(62, 191.251, 250, 1);
                height:100px;
                color:black;
                font-size: 60px;
            }
            .calibrate-button:hover{
                background-color: rgba(11, 226.357, 255, 1);
                border: thin solid rgb(4, 0, 255);
            }
            .calibrate-button:disabled{
                background-color: gray;
            }
            .car{
                background-color: rgba(62, 191.251, 250, 1);
                height:100px;
                color:black;
                font-size: 60px;
            }
            .car:hover{
                background-color: rgba(11, 226.357, 255, 1);
                border: thin solid rgb(4, 0, 255)
            }
            .allow-button{
                background-color: aquamarine;
                height: 100px;
                width: 250px;
                color:black;
                font-size: 60px;
            }
            .allow-button:hover{
                background-color: rgb(185, 255, 232);
                border: thin solid rgb(4, 0, 255)
            }
            .bubble-container {
                margin: 0;
                padding: 20px;
                position: absolute;
                top: 50%;
                left: 50%;
                -ms-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
                background-color: rgba(18, 8, 95, 0.257);
                border-radius: 10px;
                text-align: center;
                width: 350px;
            }
            .main-container{
                text-align: center;
            }
            .textField{
                margin-bottom: 10px;
                border-radius: 20px;
                width: 230px;
                height: 30px;
                background-color: black;
                border-color: gray;
                border: thin solid gray;
                color: white;
                text-align: center;
                transition: border 0.25s;
                transition: width, 0.25s;
            }
            .textField:focus{
                width: 270px;
                border: thin solid greenyellow;
            }
            .textField::-webkit-outer-spin-button, .textField::-webkit-inner-spin-button{
                -webkit-appearance: none;
            }
            .textField[type=number]{
                -moz-appearance: textfield;
            }
            .done-button{
                margin-top: 100px;
                bottom: 200px;
                background-color: #f9c452;
                background-color: rgba(62, 191.251, 250, 1);
                color: white;
                border: thin solid gray;
                border-radius: 15px;
                transition: border 0.125s;
                transition: background-color 0.1s;
                width: 300px;
                height: 100px;
                margin-bottom: 10px;
                margin-top: 10px;
            }
            .done-button:hover{
                border: thin solid #a98537;
                border: thin solid #374ea9;
                background: #e4b34a;
                background-color: rgba(11, 226.357, 255, 1);
            }
            button{
                background-color:skyblue;
                color: white;
                border: thin solid gray;
                border-radius: 15px;
                transition: border 0.125s;
                transition: background-color 0.1s;
                width: 300px;
                height: 50px;
                margin-bottom: 10px;
                margin-top: 10px;
            }
            button:disabled{
                background-color: gray;
            }
            /*button:hover:not([disabled]){
                border: thin solid rgb(255, 34, 34);
            }
            button:active:not([disabled]){
                background-color: rgb(255, 96, 96);
            }*/
            textarea:focus, input:focus{
                outline: none;
            }
            .field{
                margin: 20px;
                color: rgb(176, 176, 176);
            }
            .field h4{
                margin: 0px;
            }
            .errMsg{
                color: red;
            }
            .signal-bar{
                background-color: white; 
                width:10px; 
                margin-left: 5px;
            }
            .alert-container{
                position: absolute;
                height: 100vh;
                width: 90vw;
                left: 5%;
                top: 0;
            }
            .alert-window{
                position: relative;
                width: 80vw;
                height: 80vh;
                background-color: yellow;
                border-radius: 20px;
                opacity: 95%;
                overflow: hidden;
                text-align: center;
                top: 20%;
                left: 50%;
                -ms-transform: translate(-50%, -20%);
                transform: translate(-50%, -20%);
            }
            .tomaru-link-button{
                background-color: white;
                color: black;
                width: 50%
            }
        </style>
    </body>
</html>
